/*
 * Scanner
 */

#define clearla()	/* */
#include "whoami.h"
#include "alice.h"
#include "class.h"
#include "alctype.h"
#include "input.h"
#include "flags.h"

#ifndef RELEASE
# define PRINTT
#endif
#include "printt.h"

#include "y.tab.h"

#ifdef TURBO
extern int turbo_flag;
#endif

#define EOFCHAR -1

char	IncFilename[PATHLEN];
FILE	*IncFile;
FILE	*OldIn;
char	*OldFilename;
int	OldLineno;

inchar yytext[255];
int yylineno = 0;
char *yyfilename;
extern YYSTYPE yylval;
int lookaheadchar;
int parendepth = 0;	/* how deeply we are nested in parentheses */
FILE *yyin;		/* Pascal source file for input */
static int was_library = 0;	/* did we just encounter a library */

#define scanerror yyerror

extern char *allocstring();
extern FILE *dtrace;
int allowcom = 0;	/* nonzero if we allow comments to be returned */

yylex()
{
	int c;

	c = s_yylex(allowcom);
	printt1( "Token %d\n", c );
	return c;
}


int
s_yylex()
{
	register c;
	register char *cp;
	int f;
	char delim;

if (yylineno == 0)
	incrlineno();

while(1) {
	/*
	 * skip white space
	 */
	if (c = lookaheadchar ) {
		lookaheadchar = 0;
		}
	 else
		c = readkey();

	cp = yytext;
	while (c == ' ' || c == '\t' || c == 0 || c == 12 /* FF */) {
		c = readkey();
	}
	yytext[0] = c; yytext[1] = yytext[2] = 0;
	if( isascii(c) && (isalpha( c ) || c == '_') ) {
		do {
			*cp++ = c;
			c = readkey();
		} while (isascii(c) && (isalnum(c) || c == '_'));
		*cp = 0;

		lookaheadchar = c;
		c = look_kw(yytext);
		clearla();
		if (c == 0) {
			yylval.strval = allocstring(yytext);
			return (YID);
			}
		return c;
		}

	else if( isascii(c) && isdigit(c) ) {
		f = 0;
		do {
			*cp++ = c;
			c = readkey();
		} while (isascii(c) && isdigit(c));
		if (c == '.') {
			c = readkey();
			if (c == '.') {
				*cp = 0;
				lookaheadchar = YDOTDOT;
				yylval.strval = allocstring(yytext);
				return (YINT);
			}
infpnumb:
			f++;
			*cp++ = '.';
			if (!isascii(c) || !isdigit(c)) {
				scanerror("syntax error: digits required after decimal point");
				*cp++ = '0';
			} else
				while (isdigit(c)) {
					*cp++ = c;
					c = readkey();
				}
		}
		if (c == 'e' || c == 'E') {
			f++;
			*cp++ = c;
			if ((c = lookaheadchar) == 0)
				c = readkey();
			if (c == '+' || c == '-') {
				*cp++ = c;
				c = readkey();
			}
			if (!isascii(c) || !isdigit(c)) {
				scanerror("syntax error: digits required in exponent");
				*cp++ = '0';
			} else
				while (isascii(c) && isdigit(c)) {
					*cp++ = c;
					c = readkey();
				}
		}
		*cp = 0;
		lookaheadchar = c;
		clearla();
		yylval.strval = allocstring(yytext);
		if (f)
			return (YNUMB);
		return (YINT);
		}
	printt2("Select on char %d - %c\n", c, c );
	switch (c) {
	case EOF:
		return 0;
	case ' ':
	case '\t':
	case 12: /* form feed */
		break;
	case '"':
	case '\'':
		*cp++ = delim = c;
		do {
			do {
				c = readkey();
				if (c == '\n' || c == EOFCHAR) {
					scanerror("syntax error: unmatched quote for string" );
					if (cp == yytext)
						*cp++ = ' ', cp++;
					return YILLCH;
				}
				*cp++ = c;
			} while (c != delim);
			c = readkey();
		} while (c == delim);
		if( c == '^' || c== '#' ) {
			par_error( "Can't imbed ^A or #nnn codes in strings.  Try concatenating strings together\n" );
			}
		*--cp = 0;
#ifndef TURBO
		if (cp == yytext && delim == '\'') {
			scanerror("syntax error: null string not allowed");
			*cp++ = ' ';
			*cp++ = 0;
		}
#endif
		lookaheadchar = c;
		clearla();
		/* len of 2 means 1 char and 1 quote char */
		if (delim == '"' || strlen(yytext) != 2) {
			yylval.strval = allocstring(yytext);
			return (YSTRING);
			}
		else  {
			yylval.intval = yytext[1];
			return (YCHAR);
			}
	case '.':
		c = readkey();
		if (c == '.')
			return (YDOTDOT);
		if (isdigit(c)) {
			scanerror("syntax error: digits required before decimal point");
			*cp++ = '0';
			goto infpnumb;
		}
		lookaheadchar = c;
		clearla();
		return '.';

	case '\n':
		break;
	case '{': /* { ... } comment */
		delim = '{';
comment:
		c = readkey();
#ifdef TURBO
		if (c == '$' && turbo_flag) {
			f = scanturbo();
			if (f >= 0)
				return f;
			}
		else
#endif
		if (c == '+') {
			/* Stubs generated by alist, we know they use {} */
			f = scanstub();
			if (f == YC_BLCOMMENT) {
				/* Kludge - throw away to keep grammar LALR.
				 * Doesn't matter since they will be generated
				 * in all appropriate places anyway.
				 */
				continue;	/* outer while loop */
			}
			if (f >= 0)
				return f;
		}
		else {
			for (;;) {
				if (delim=='{' && c == '}') {
					break;
				}
				if (c == '\n') {
					/* Break into one line pieces */
					*cp++ = 0;
					savecomment(yytext);
					cp = yytext;
					*cp = 0;
				} else {
					*cp++ = c;
					if (c <= 0) {
						/* nonterminated comment */
						/* This "can't happen" */
						fatal("Bug - nonterm comment");
					}
				}
				c = readkey();
				if (delim=='(' && c == ')' && cp[-1] == '*') {
					*--cp = 0;
					break;
				}
			}
			*cp++ = 0;
		}
		/*
		 * Comments generated by the lister for procedure or
		 * function calls (in parens, ending in =) are ignored.
		 */
		if (parendepth <= 0 || cp[-2] != '=')
			savecomment(yytext);
		clearla();
		cp = yytext;
		*cp = 0;
		if (allowcom)
			return 0;
		break;
	case ':':
		if ((c=readkey()) == '=') {
			*++cp = c;
			return YCOLEQUALS;
			}
		lookaheadchar = c;
		clearla();
		return ':';
	case '(':
		if ((c=readkey()) == '*') {
			delim = '(';
			goto comment;
			}
		lookaheadchar = c;
		clearla();
		parendepth++;
		return '(';
	case ')':
		parendepth--;
		return ')';
	case '$':
		while( isxdigit(c = readkey()) )
			*++cp = c;
		*++cp = 0;
		lookaheadchar = c;
		if( strlen(yytext) <= 1 )	
			return YILLCH;
		yylval.strval = allocstring(yytext);
		return YINT;
	case '#':
		c = readkey();
		if( c == '$' ) {
			unsigned hxnum;
			while( isxdigit(c = readkey()) )
				hxnum = (hxnum << 4) + ((c > '9') ? 9 : 0)
					+ (c & 0xf);

			lookaheadchar = c;
			yylval.intval = hxnum;
			return YCHAR;
			}
		else while (isdigit(c)) {
			*++cp = c;
			c = readkey();
			}
		*++cp = 0;
		lookaheadchar = c;
		yylval.intval = atoi(&yytext[1]);
		return YCHAR;
	case '^':
		c = readkey();
		if (strchr("\\_", c)) {		/* others include []@^ */
			yylval.intval = c & 0x1f;
			return YCHAR;
		}
		else {
			lookaheadchar = c;
			yylval.intval = '^';
			return YPTR;
		}
	case '@':
		yylval.intval = '@';
		return YPTR;
	case ';':
	case ',':
	case '=':
	case '*':
	case '+':
	case '/':
	case '-':
	case '[':
	case ']':
	case '<':
	case '>':
	case '_':
	case '\\':
	case '}':	/* for DO..SET */
		return c;
	case YDOTDOT:
		return YDOTDOT;

	default:
		if (c <= 0)
			return (0);
		do
			lookaheadchar = readkey();
		while (lookaheadchar == c);
		clearla();
		printt1("illegal char in scanner %o\n", c);
		return (YILLCH);
	}
  
  } /* big while */
}

#ifdef TURBO
int extra_tokens[] = { YOTHERWISE, YSTTYPE, YSHL, YSHR, YXOR,
			YABSOLUTE, YEXTERNAL, YINLINE, YOVERLAY, 0 };
#endif

struct kwtab {
	char *word;
	int ttype;
} kwtab[] = {
#define START_REAL 0
	"absolute",	YABSOLUTE,
	"and",		YAND,
	"array",	YARRAY,
	"begin",	YBEGIN,
	"case",		YCASE,
	"const",	YCONST,
	"div",		YDIV,
	"do",		YDO,
	"downto",	YDOWNTO,
	"else",		YELSE,
	"end",		YEND,
	"external",	YEXTERNAL,
	"file",		YFILE,
	"for",		YFOR,
	"function",	YFUNCTION,
	"goto",		YGOTO,
	"if",		YIF,
	"in",		YIN,
	"inline",	YINLINE,
	"label",	YLABEL,
	"mod",		YMOD,
	"nil",		YNIL,
	"not",		YNOT,
	"of",		YOF,
	"or",		YOR,
#ifdef TURBO
	"otherwise",	YOTHERWISE,
	"overlay",	YOVERLAY,
#endif
	"packed",	YPACKED,
	"procedure",	YPROCEDURE,
	"program",	YPROG,
	"record",	YRECORD,
	"repeat",	YREPEAT,
	"set",		YSET,
#ifdef TURBO
	"shl",		YSHL,
	"shr",		YSHR,
	"string",	YSTTYPE,
#endif
	"then",		YTHEN,
	"to",		YTO,
	"type",		YTYPE,
	"until",	YUNTIL,
	"var",		YVAR,
	"while",	YWHILE,
	"with",		YWITH,
#ifdef TURBO
	"xor",		YXOR,
#endif
	0,		0,
};



int
look_kw(str)
reg char *str;
{
	register int l;
	int h, m, r;
	char text[255];
	char	*tp;

	
	/* copy the lowecase of str into text */
	for (tp = text; (*tp = (*str ? (*str | 0x20) : 0)); tp++, str++)
		;

	l=START_REAL; h=sizeof(kwtab) / sizeof(kwtab[0]) - 2;
	while (l <= h) {
		m = (l+h)/2;
		r = strcmp(kwtab[m].word, text);
		if (r < 0)
			l = m+1;
		else if (r > 0)
			h = m-1;
		else {
#ifdef TURBO
			/* pass over extended reserved words */
			if( !turbo_flag ) {
				int i;
				for( i = 0; extra_tokens[i]; i++ )
					if( extra_tokens[i] == kwtab[m].ttype ) 
						return 0;
				}
#endif
			return kwtab[m].ttype;
			}
	}
	return 0;
}

readkey()
{
	int c;
	extern int listing;

	c = getc(yyin);
	if (c == EOF && IncFile) {
		endInclude();
		c = getc(yyin);
		}

	if(dtrace) putc(c, dtrace);
	if (listing && c != EOF) putc(c, stdout);
	if (c == '\n')
		incrlineno();
	return c;
}

yyerror(s)
char *s;
{
	message( "%s at or near %s\n", s, yytext );
}

incrlineno()
{
	extern int listing;
	int lac;	/* lookahead char */

	yylineno++;
	if( was_library )
		was_library--;

	lac = getc(yyin);
	ungetc(lac, yyin);
	if (listing && lac != EOF) printf("(%s)%4d\t", yyfilename, yylineno);
}

#define MAXCOM 250	/* maximum number of consecutive comment lines */
char *combuf[MAXCOM];
int ncombuf = 0;
int firstcombuf = 0;

/* Save comtext as a buffered comment. */
savecomment(comtext)
char *comtext;
{
	printt1("savecomment('%s')\n", comtext);
	if (ncombuf >= MAXCOM)
		fatal("Too many consecutive comments");
	combuf[ncombuf++] = allocstring(comtext);
}

/* Return 1 if there are comments buffered */
iscombuf()
{
	if (ncombuf > 0)
		return 1;
	else
		return 0;
}

/* Return 1 if the next token is a comment */
iscomnext()
{
	register int c;

	c = lookaheadchar;
	while (c == ' ' || c == '\t' || c == '\n' || c == 12 /* ff*/|| c == 0) {
		c = readkey();
	}
	lookaheadchar = c;
	if (lookaheadchar == '{') {
		int	peek;

		peek = getc(yyin);		/* ugly */
		ungetc(peek, yyin);
		if (!(peek == '+' || (turbo_flag && peek == '$')))
			return 1;
	}
	return 0;
}

/* Return the text of the next (fifo) buffered comment */
char *
nextcomment()
{
	char *r;
	int i;

	printt2("nextcomment: firstcombuf %d, ncombuf %d\n", firstcombuf, ncombuf);
	r = combuf[firstcombuf++];
	if (firstcombuf >= ncombuf) {
		/* Don't free them because we use them in the tree */
	printt0("nextcomment resets firstcombuf, ncombuf\n");
		firstcombuf = 0;
		ncombuf = 0;
	}
	printt1("nextcomment returns '%s'\n", r);
	return r;
}

/* Scoop up all waiting comments */
scoop_comments()
{
	allowcom = 1;
	printt0("scooping comments\n");
	while (iscomnext())
		yylex();
	printt0("not scooping comments anymore\n");
	allowcom = 0;
}

/* Table to be used when reading stubs in from text file */
struct toktab {
	int class;	/* class to create stub with */
	int tok;	/* token to return to parser */
};

struct toktab stubtab[] = {
C_ROOT,		YC_ROOT,
C_COMMENT,	YC_COMMENT,
C_LABEL,	YC_LABEL,
C_PROC_ID,	YC_PROC_ID,
C_FUN_ID,	YC_FUN_ID,
C_PROGRAM,	YC_PROGRAM,
C_DECLARATIONS,	YC_DECLARATIONS,
C_CONST_DECL,	YC_CONDECL,
C_TYPE_DECL,	YC_TYPE_DECL,
C_VAR_DECL,	YC_VAR_DECL,
C_CONSTANT,	YC_CONSTANT,
C_TYPE,		YC_TYPE,
C_TYPEID,	YC_TYPEID,
C_SIM_TYPE,	YC_SIM_TYPE,
C_ST_TYPE,	YC_ST_TYPE,
C_FIELD,	YC_FIELD,
C_FORMAL,	YC_FORMAL,
C_STATEMENT,	YC_STATEMENT,
C_CASE,		YC_CASE,
C_VAR,		YC_VAR,
C_EXP,		YC_EXP,
C_DECL_ID,	YC_DECL_ID,
C_HIDECL_ID,	YC_HIDECL_ID,
C_BLCOMMENT,	YC_BLCOMMENT,
C_VARIANT,	YC_VARIANT,
C_FLD_NAME,	YC_FLD_NAME,
C_PNAME,	YC_PNAME,
0,		0
};

struct toktab classtab[] = {
C_DECLARATIONS,	YCLASS_DECL,
C_CONST_DECL,	YCLASS_CONST,
C_TYPE_DECL,	YCLASS_TYPE,
C_VAR_DECL,	YCLASS_VAR,
C_FIELD,	YCLASS_FIELD,
C_VARIANT,	YCLASS_VARIANT,
C_STATEMENT,	YCLASS_STAT,
C_CASE,		YCLASS_CASE,
0,		0
};

Boolean
lookuptok(string, table, class, tok)
char	*string;
struct toktab table[];
int	*class;
int	*tok;
{
	register int	i;

	for (i = 0; table[i].tok; i++) {
		if (strcmp(string, classname(table[i].class)) == 0) {
			*class = table[i].class;
			*tok = table[i].tok;
			return TRUE;
			}
		}
	return FALSE;
}

/* Read in a stub and return the appropriate stub token */
scanstub()
{
	char namebuf[PATHLEN];
	int	class;
	int	tok;

	/* The stub looks like {+ Name } and the {+ have already been read */

	getcom(namebuf, sizeof(namebuf));

	if (strncmp(namebuf, "I ", 2) == 0) {
		include(namebuf+2);
		return s_yylex();		/* advance to next token */
		}
#ifdef HAS_LIBRARY
	if (strncmp("Library ", namebuf, 8) == 0 {
		nodep np;
		char *buf;
		char *the_comment, *the_filename;

		yylval.treeval = np = tree(N_LIBRARY, 0L, 0L, 0L, 0L );
		/*
		 * Kid1 is the comment,
		 * Kid2 are the decls,
		 * Kid3 is the filename,
		 * Kid4 is the code block,
		 */
		was_library = 2
		/* We basically want to make this look like we are returning
		 * a declarations stub.
		 */

		buf = &namebuf[0] + strlen( "Library " );
		/* Skip spaces */
		while( *buf == ' ' || *buf == '\t' ) buf++;
		if( *buf != '\"' )
			par_error( "Illegal filename format for library\n" );

		the_filename = buf;

		while( *buf && *buf != '\"' ) buf++;

		if( *buf == '\000' )
			par_error( "No closing quote in library filename\n" );

		/* Skip past the quote */	
		buf++;
		the_comment = buf;

		s_kid1( np, allocstring( the_comment ) );
		s_kid2( np, NIL );
		s_kid3( np, allocstring( the_filename) );
		s_kid4( np, NIL );

		/* Go and load in the library */
		search_lib( np, LOAD );

		/* and return the library node */
		return YC_DECLARATIONS;
	}
#endif HAS_LIBRARY

	if (strncmp("Revealed ", namebuf, 9) == 0) {
		yylval.treeval = tree(N_T_COMMENT, allocstring(namebuf + 9));
		return YREVEAL;
		}
	if (strncmp("Class ", namebuf, 6) == 0) {
		if (lookuptok(namebuf+6, classtab, &class, &tok))
			return tok;
		}
	if( strcmp( "do", namebuf ) == 0 )
		return YDO;
	if (strncmp("Hide", namebuf, 4) == 0) {
		if (namebuf[4] == '\0') {
			yylval.intval = 0;
			return YHIDE;
			}
		else if (namebuf[5] == 'e') {
			return YHIDEEND;
			}
		else {
			yylval.intval = 1;
			return YHIDE;
			}
		}
	if (lookuptok(namebuf, stubtab, &class, &tok)) {
		yylval.treeval = make_stub(class);
		return tok;
		}

	strcpy(yytext, namebuf);
	return -1;
}

getcom(buf, bufsize)
char	*buf;
{
	char	c;
	char	*p;

	p = buf;
	while ((c = readkey()) == ' ')
		;
	*p++ = c;
	/* kludge so that {+do is a special token */
	if( c == 'd' && ( *p++ = readkey() ) == 'o' ) {
		*p = 0;
		return;
		}
	for(;;) {
		c = readkey();
		if( c == '}' )
			break;
		if( c == '*' ) {
			if( (c = readkey()) == ')' )
				break;
			*p++ = '*';
			}
		if( p - buf >= bufsize ) {
			par_error( "Comment too long" );
			break;
			}
		*p++ = c;
		}

	*p = 0;
}

scanturbo()
{
	char	buf[PATHLEN];
	nodep	iochecking();

	getcom(buf, sizeof(buf));

	switch (buf[0] & ~0x20) {
	case 'I':
		if (buf[1] == '+' || buf[1] == '-') {
			yylval.treeval = iochecking(buf[1] != '+');
			return YC_STATEMENT;
			}
		 else  {
			int i;
			/* If we just loaded this as a library, then
			 * we ignore this include file
			 * since library nodes are printed as:
			 * {+ Library "filename.ap" comment }
			 * {+I filename.pas}
			 */
			if( was_library )
				break;
			for( i = 1; isspace( buf[i] ); i++ )
				;
			include(buf+i);
			return s_yylex();	/* advance to next token */
			}
		break;
	case 'V':
		nonfatal("This program contains the Turbo Pascal {$V} option.\n\
Be sure to use the -v option when running Alice Pascal.");
		break;
	}
	strcpy(yytext, buf);
	return -1;
}

nodep
iochecking(flag)
int	flag;
{
	nodep	ret;

	ret = tree(N_ST_CALL,
		   symref("iochecking"),
		   newlist(tree(N_CON_INT, NCAST (flag ? "1" : "0"),
				NCAST flag)));
	ret = tree(N_HIDE,
		   tree(N_T_COMMENT, NCAST (flag ? "$I-" : "$I+")),
		   newlist(ret));
	or_2flag(ret, NF2_KEEP_HIDDEN);

	return ret;
}

include(filename)
char	*filename;
{
	if (IncFile)
		fatal("only one level of inclusion is permitted");

	strcpy(IncFilename, filename);
	if ((IncFile = fopen(IncFilename, "r")) == NULL)
		fatal("can't open include file \"%s\"", IncFilename);

	OldIn = yyin;
	yyin = IncFile;
	OldFilename = yyfilename;
	yyfilename = IncFilename;
	OldLineno = yylineno;
	yylineno = 0;
}

endInclude()
{
	fclose(IncFile);
	IncFile = NULL;
	yyin = OldIn;
	yyfilename = OldFilename;
	yylineno = OldLineno;
}
